\chapter{Implementacja}
Rozdzia³ ten poœwiêcono aby omówiæ sposób implementacji prototypu aplikacji przy pomocy wymienionych rozdzia³ wy¿ej technologii.

\section{Architektura systemu}
System zosta³ podzielony na warstwy tak jak na rys.~\ref{fig:architekturasystemu}. Strza³ki symbolizuj¹ ich zale¿noœæ od siebie. Zastosowanie tego wzorca pozwala na niezale¿noœæ bazy danych, zewnêtrznych serwisów oraz warstwy prezentacji(w tym przypadku jest to API do zewnêtrznego serwera z warstw¹ prezentacyjn¹) i ich szybk¹ oraz wygodn¹ wymianê w razie potrzeby bez ingerowania w wewnêtrzne warstwy aplikacji.

\begin{figure}[htp]
	\centering
	\includegraphics[width=0.5\linewidth]{rys05/cleanCodeDiagram.png}
	\caption{Zale¿noœci miêdzy poszczególnymi warstwami aplikacji}
	\label{fig:architekturasystemu}
\end{figure}
\newpage
\subsection{Domain}

Zawiera wszystkie klasy u¿yte w bazie danych. Znajduj¹ siê tu tak¿e enumy oraz logika z nimi zwi¹zana jak np. metoda do wydobywania opisu z obiektu typu enum.

\begin{figure}[htp]
	\centering
	\includegraphics[width=0.3\linewidth]{rys05/domainTree.png}
	\caption{Pliki i foldery znajduj¹ce siê w warstwie domain}
	\label{fig:domainTree}
\end{figure}

\newpage

\subsection{Persistence}
Odpowiada za konfiguracje poszczególnych obiektów bazodanowych oraz za po³¹czenie z baz¹ danych. Oddzielenie tej warstwy od warstwy domain pozwala na szybk¹ i wygodn¹ zmianê dostarczyciela bazy danych bez potrzeby edytowania samych obiektów. Znajduj¹ siê tu tak¿e migracje.

\begin{figure}[htp]
	\centering
	\includegraphics[width=0.3\linewidth]{rys05/persistanceTree.png}
	\caption{Pliki i foldery znajduj¹ce siê w warstwie persistence}
	\label{fig:persistenceTree}
\end{figure}


\newpage
\subsection{Application}
Zawiera ca³¹ logikê aplikacji. Jest zale¿na od warstwy domain i nie ma zale¿noœci w innych warstwach lub projektach. Zawiera komendy oraz zapytania (commands/queries) które s¹ obs³ugiwane przez rozszerzenie MediatR patrz rys.~\ref{fig:divisionCQRS}.
\begin{figure}[h]
	\centering
	\includegraphics[width=0.3\linewidth]{rys05/divisionCQRS.png}
	\caption{Struktura komend i zapytañ dla obiektu division}
	\label{fig:divisionCQRS}
\end{figure}
 Pozwala to na oddzielenie zapytañ pobieraj¹cych dane z bazy od komand które zmieniaj¹ stan bazy danych.W tej klasie zdefiniowane s¹ interfejsy implementowane póŸniej na zewn¹trz tej warstwy. Np.~gdy aplikacja potrzebowa³a dostêpu do serwisu wysy³ania zdjêæ do chmury, nowy interfejs zosta³ dodany do aplikacji, a jego implementacja zosta³a stworzona w warstwie infrastructure.

\begin{figure}[h!tp]
	\centering
	\includegraphics[width=0.3\linewidth]{rys05/applicationTree.png}
	\caption{Pliki i foldery znajduj¹ce siê w warstwie application}
	\label{fig:applicationTree}
\end{figure}

\newpage
\subsection{Infrastructure}
Zawiera klasy zapewniaj¹ce dostêp do zewnêtrznych zasobów takich jak chmura do przechowywania zdjêæ, generator tokenów autoryzacyjnych. Klasy te s¹ nastêpnie implementowane przy pomocy dependency injection za pomoc¹ interfejsów stworzonych w warstwie application.
\begin{figure}[htp]
	\centering
	\includegraphics[width=0.3\linewidth]{rys05/infrastructureTree.png}
	\caption{Pliki i foldery znajduj¹ce siê w warstwie infrastructure}
	\label{fig:infrastructureTree}
\end{figure}

\subsection{API}
Zawiera controllery które s¹ endpointami przez które wysy³ane s¹ zapytania z aplikacji klienckiej. Znajduj¹ siê tu równie¿ klasy konfiguruj¹ce rozszerzenie SignalR s³u¿¹ce do wysy³ania wyników meczu na ¿ywo, oraz klasa poœrednicz¹ca w przechwytywaniu b³êdów. W klasie Startup znajduje siê konfiguracja obs³ugi ¿¹dañ wysy³anych do aplikacji, a tak¿e wstrzykiwane s¹ serwisy i interfejsy.

\begin{figure}[htp]
	\centering
	\includegraphics[width=0.25\linewidth]{rys05/apiTree.png}
	\caption{Pliki i foldery znajduj¹ce siê w warstwie api}
	\label{fig:apiTree}
\end{figure}

\newpage



\section{Baza danych}

Bazê danych stworzono stosuj¹c podejœcie Code-First, czyli najpierw zosta³y utworzone obiekty w kodzie reprezentuj¹ce poszczególne tabele, a nastêpnie zosta³y one zmapowane przy u¿yciu rozszerzenia Entity Framework Core na SQL-ow¹ bazê danych. Podejœcie takie pozwala na szybkie i wygodne wprowadzanie zmian dziêki migracjom. Schemat tego podejœcia przedstawiono na rys.~\ref{fig:schematcodefirst}.

\begin{figure}[htp]
	\centering
	\includegraphics[width=0.7\linewidth]{rys05/dev-workflow.png}
	\caption{Schemat tworzenia bazy danych w podejœciu Code-First, \cite{CodeFirst}}
	\label{fig:schematcodefirst}
\end{figure}

Schemat zaprojektowanej bazy danych na potrzeby aplikacji przedstawiono na rys.~\ref{fig:databaseschema}.
Jednak z powodu du¿ej iloœci tabel i relacji w nie znalaz³a siê na nim tabela \textit{Player}.
Tabelê tê wraz z jej relacjami przedstawia rys.~\ref{fig:playerdatabaseschema}.
W bazie przechowywane s¹ informacje o ka¿dym wydarzeniu które zosta³o dodane przez program do statystyk. Ka¿de wydarzenie jest powi¹zane z tabel¹ \textit{Incident} która zawiera informacje o meczu, czasie oraz kwarcie w której zdarzenie mia³o miejsce i typie incydentu. Tabele odpowiadaj¹ce za gromadzenie danych o zdarzeniach to: \textit{Shot}, \textit{Substitution},  \textit{Foul}, \textit{FreeThrow}, \textit{Assist}, \textit{Rebound}, \textit{Block}, \textit{Steal}, \textit{Turnover}



\begin{figure}[htp]
	\centering
	\includegraphics[angle=90, width=0.95\linewidth]{rys05/databaseschema2.png}
	\caption{Schemat bazy danych wraz z relacjami (bez tabeli Player)}
	\label{fig:databaseschema}
\end{figure}


\begin{figure}[htp]
	\centering
	\includegraphics[width=1\linewidth]{rys05/playerdatabaseschema2.png}
	\caption{Tabela Player wraz z tabelami relacyjnymi}
	\label{fig:playerdatabaseschema}
\end{figure}







