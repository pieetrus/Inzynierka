\chapter{Architektura systemu}
Rozdzia≥ ten poúwiÍcono aby omÛwiÊ sposÛb implementacji prototypu aplikacji przy pomocy wymienionych rozdzia≥ wyøej technologii. ArchitekturÍ przedstawiono na schemacie (rys.~\ref{fig:webappschema}).

\begin{figure}[htp]
	\centering
	\includegraphics[width=0.7\linewidth]{rys05/webappschema.png}
	\caption{Schemat architektury systemu do zarzπdzania ligπ sportowπ. èrÛd≥o: Na podstawie~\cite{MarkDabbs}}
	\label{fig:webappschema}
\end{figure}

\section{Back-end}
System zosta≥ podzielony na warstwy tak jak na schemacie (rys.~\ref{fig:architekturasystemu}). Strza≥ki symbolizujπ ich zaleønoúÊ od siebie. Zastosowanie tego wzorca pozwala na niezaleønoúÊ bazy danych, zewnÍtrznych serwisÛw oraz warstwy prezentacji (w tym przypadku jest to API do zewnÍtrznego serwera z warstwπ prezentacyjnπ) i ich szybkπ oraz wygodnπ wymianÍ bez ingerowania w wewnÍtrzne warstwy aplikacji.

\begin{figure}[h!tp]
	\centering
	\includegraphics[width=0.3\linewidth]{rys05/cleanCodeDiagram.png}
	\caption{Zaleønoúci miÍdzy poszczegÛlnymi warstwami aplikacji}
	\label{fig:architekturasystemu}
\end{figure}
\newpage
\subsection{Domain}

Zawiera wszystkie klasy uøyte w bazie danych. Znajdujπ siÍ tu takøe enumy oraz logika z nimi zwiπzana jak np. metoda do wydobywania opisu z obiektu typu enum. Struktura tej warstwy znajduje siÍ na rysunku \ref{fig:domainTree}.

\subsection{Persistence}
Odpowiada za konfiguracje poszczegÛlnych obiektÛw bazodanowych oraz za po≥πczenie z bazπ danych. Oddzielenie tej warstwy od domain pozwala na szybkπ i wygodnπ zmianÍ dostarczyciela bazy danych bez potrzeby edytowania samych obiektÛw. Znajdujπ siÍ tu takøe migracje. StrukturÍ tej warstwy przedstawiono na rysunku \ref{fig:persistenceTree}.

\begin{figure}[h]
	\centering
	\begin{subfigure}{.5\textwidth}
			\centering
			\includegraphics[width=.6\linewidth]{rys05/domainTree.png}
			\caption{}
			\label{fig:domainTree}
	\end{subfigure}%
	\begin{subfigure}{.5\textwidth}
		\centering
		\includegraphics[width=0.7\linewidth]{rys05/persistanceTree.png}
		\caption{}
		\label{fig:persistenceTree}
	\end{subfigure}
	\caption{Pliki i foldery znajdujπce siÍ w warstwie a) Domain b) Persistence}
	\label{fig:tesdst}
\end{figure}


\subsection{Application}
Zawiera ca≥π logikÍ aplikacji. Jest zaleøna od warstwy domain i nie ma zaleønoúci w innych warstwach lub projektach. Zawiera komendy oraz zapytania (commands/queries) ktÛre sπ obs≥ugiwane przez rozszerzenie MediatR. Przyk≥adowπ strukturÍ logiki zwiπzanej z dywizjami pokazano na rysunku \ref{fig:divisionCQRS}.
\newpage
\begin{figure}[h]
	\centering
	\includegraphics[width=0.5\linewidth]{rys05/divisionCQRS.png}
	\caption{Struktura komend i zapytaÒ dla obiektu division}
	\label{fig:divisionCQRS}
\end{figure}

Zastosowanie wzorca CQRS (Command Query Responsibility Segregation) pozwala na oddzielenie zapytaÒ pobierajπcych dane z bazy od komand ktÛre zmieniajπ stan bazy danych. W tej klasie zdefiniowane sπ interfejsy implementowane pÛüniej na zewnπtrz tej warstwy. Np.~gdy aplikacja potrzebowa≥a dostÍpu do serwisu wysy≥ania zdjÍÊ do chmury, nowy interfejs zosta≥ dodany do aplikacji, a jego implementacja zosta≥a stworzona w warstwie infrastructure.

\begin{figure}[h!tp]
	\centering
	\includegraphics[width=0.3\linewidth]{rys05/applicationTree.png}
	\caption{Pliki i foldery znajdujπce siÍ w warstwie application}
	\label{fig:applicationTree}
\end{figure}

\newpage
\subsection{Infrastructure}
Zawiera klasy zapewniajπce dostÍp do zewnÍtrznych zasobÛw takich jak chmura do przechowywania zdjÍÊ, generator tokenÛw autoryzacyjnych. Klasy te sπ nastÍpnie implementowane przy pomocy dependency injection za pomocπ interfejsÛw stworzonych w warstwie application.
\begin{figure}[htp]
	\centering
	\includegraphics[width=0.3\linewidth]{rys05/infrastructureTree.png}
	\caption{Pliki i foldery znajdujπce siÍ w warstwie infrastructure}
	\label{fig:infrastructureTree}
\end{figure}

\subsection{API}
Zawiera controllery ktÛre sπ endpointami przez ktÛre wysy≥ane sπ zapytania z aplikacji klienckiej. Znajdujπ siÍ tu rÛwnieø klasy konfigurujπce rozszerzenie SignalR s≥uøπce do wysy≥ania wynikÛw meczu na øywo, oraz klasa poúredniczπca w przechwytywaniu b≥ÍdÛw. W klasie Startup znajduje siÍ konfiguracja obs≥ugi øπdaÒ wysy≥anych do aplikacji, a takøe wstrzykiwane sπ serwisy i interfejsy.

\begin{figure}[htp]
	\centering
	\includegraphics[width=0.25\linewidth]{rys05/apiTree.png}
	\caption{Pliki i foldery znajdujπce siÍ w warstwie api}
	\label{fig:apiTree}
\end{figure}

\newpage



\section{Baza danych}

BazÍ danych stworzono stosujπc podejúcie Code-First, czyli najpierw zosta≥y utworzone obiekty w kodzie reprezentujπce poszczegÛlne tabele, a nastÍpnie zosta≥y one zmapowane przy uøyciu rozszerzenia Entity Framework Core na SQL-owπ bazÍ danych. Podejúcie takie pozwala na szybkie i wygodne wprowadzanie zmian dziÍki migracjom. Schemat projektowania bazy w ten sposÛb przedstawia rysunek \ref{fig:schematcodefirst}.

\begin{figure}[htp]
	\centering
	\includegraphics[width=0.7\linewidth]{rys05/dev-workflow.png}
	\caption{Schemat tworzenia bazy danych w podejúciu Code-First, èrÛd≥o: \cite{CodeFirst}}
	\label{fig:schematcodefirst}
\end{figure}

Schemat zaprojektowanej bazy danych na potrzeby aplikacji przedstawiono na rysunku ~\ref{fig:databaseschema}. Z powodu duøej iloúci tabel i relacji nie znalaz≥a siÍ na nim tabela \textit{Player} oraz \textit{AspNetUsers}. TabelÍ \textit{Player} wraz z jej relacjami przedstawia rysunku ~\ref{fig:playerdatabaseschema}, natomiast tabela \textit{AspNetUsers} znajduje siÍ na rysunku ~\ref{fig:userdatabaseschema}.
W bazie przechowywane sπ informacje o kaødym wydarzeniu ktÛre zosta≥o dodane przez program do statystyk. Kaøde wydarzenie jest powiπzane z tabelπ \textit{Incident} ktÛra zawiera informacje o meczu, czasie oraz kwarcie w ktÛrej zdarzenie mia≥o miejsce i typie incydentu. Tabele odpowiadajπce za gromadzenie danych o zdarzeniach to: \textit{Shot}, \textit{Substitution}, \textit{Foul}, \textit{FreeThrow}, \textit{Assist}, \textit{Rebound}, \textit{Block}, \textit{Steal}, \textit{Turnover}. Z kaødym takim zdarzeniem jest zwiπzany zawodnik/zawodnicy lub druøyna/druøyny.
W tabeli \textit{Season} gromadzone sπ informacje na temat stworzonych sezonÛw, analogicznie tabela \textit{Division} gromadzi informacje na temat stworzonych dywizji. W tabeli \textit{Season\_Division} znajdujπ siÍ dywizje dla danego sezonu.
Z tabelπ tπ zwiπzane sπ tabele \textit{Player\_Season} oraz \textit{Team\_Season}, ktÛre magazynujπ informacje na temat zawodnika oraz druøyny w danym sezonie oraz dywizji. 
Tabela \textit{Match} magazynuje informacje na temat meczu, czasie jego startu, koÒca, druøyn ktÛre ze sobπ grajπ (wystÍpuje tu relacja zarÛwno do tabeli \textit{Team\_Match} oraz \textit{Team\_Season}) oraz koloru koszulek. WystÍpujπ tu relacje z tabelπ \textit{Player\_Match} oraz \textit{Team\_Match} w ktÛrych magazynowane sπ statystyki z powiπzanych meczÛw.
W tabeli \textit{AspNetUsers} gromadzone sπ informacje na temat konta uøytkownika. WystÍpuje tu relacja z tabelπ \textit{Photos} w ktÛrej mieúci siÍ link do zdjÍcia, oraz z tabelπ \textit{AspNetUserRoles} w ktÛrej gromadzona jest informacja o rolach ktÛre sπ przypisane do danego uøytkownika. Role natomiast magazynowane sπ w tabeli \textit{AspNetRoles}.



\begin{figure}[htp]
	\centering
	\includegraphics[angle=90, width=0.95\linewidth]{rys05/databaseschema.png}
	\caption{Schemat bazy danych wraz z relacjami (bez tabeli \textit{Player})}
	\label{fig:databaseschema}
\end{figure}


\begin{figure}[htp]
	\centering
	\includegraphics[width=1\linewidth]{rys05/playerdatabaseschema.png}
	\caption{Tabela \textit{Player} wraz z tabelami relacyjnymi}
	\label{fig:playerdatabaseschema}
\end{figure}
\newpage
\begin{figure}[htp]
	\centering
	\includegraphics[width=0.5\linewidth]{rys05/userdatabaseschema.png}
	\caption{Tabela \textit{AspNetUsers} wraz z tabelami relacyjnymi}
	\label{fig:userdatabaseschema}
\end{figure}






