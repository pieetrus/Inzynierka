\chapter{Implementacja}

\section{Rejestracja, logowanie oraz role}
Do stworzenia u¿ytkowników wykorzystano wbudowany w .NETa interfejs API o nazwie Identity, który pozwala na zarz¹dzanie u¿ytkownikami, has³ami, danymi profilu, rolami oraz tokenami.
Po rejestracji informacje na temat u¿ytkownika zachowywane s¹ w bazie, jego has³o zostaje zhaszowane (tym zajmuje siê Identity, przez co nie by³o potrzeby implementacji tego na w³asn¹ rêkê).
Przed samym procesem tworzenia u¿ytkownika nastêpuje sprawdzenie, czy u¿ytkownik o podanych danych nie znajduje siê ju¿ w bazie i w takim przypadku proces przerywany zostaje wyj¹tkiem.\\
Je¿eli jest to nowy u¿ytkownik, na podstawie przes³anych danych tworzony jest obiekt \textit{AppUsera} oraz przypisana zostaje mu rola.
W przypadku gdy u¿ytkownik zostanie pomyœlnie dodany do bazy zwracany jest obiekt \textit{User} wraz z wygenerowanym tokenem pozwalaj¹cym na automatyczne zalogowanie siê do aplikacji. Kod odpowiadaj¹cy za rejestracjê nowego u¿ytkownika znajduje siê na listingu \ref{list:req1}.
\lstset{style=sharpcstyle}
{\belowcaptionskip=-20pt
\begin{lstlisting}[label=list:req1,caption=Rejestracja nowego u¿ytkownika]
	if (await _context.AppUser.AnyAsync(x => x.Email == request.Email, cancellationToken))
	throw new BadRequestException("Email already exist");
	
	if (await _context.AppUser.AnyAsync(x => x.UserName == request.UserName, cancellationToken))
	throw new BadRequestException("Username already exist");
	
	var user = new AppUser
	{
		DisplayName = request.DisplayName,
		Email = request.Email,
		UserName = request.UserName,
	};
	
	var result = await _userManager.CreateAsync(user, request.Password);
	await _userManager.AddToRoleAsync(user, "USER");
	
	if (result.Succeeded)
	{
		return new Dto.User
		{
			DisplayName = user.DisplayName,
			Username = user.UserName,
			Token = _jwtGenerator.CreateToken(user),
		};
	}
	throw new Exception("Problem creating user");
\end{lstlisting}
}

Podczas logowania nastêpuje sprawdzenie czy u¿ytkownik istnieje w bazie i czy has³o jest prawid³owe. Je¿eli tak z bazy zostaje pobierana rola przypisana do u¿ytkownika oraz adres url zdjêcia je¿eli takowe wczeœniej zosta³o wrzucone i generowany jest token. W przypadku niepowodzenia zwracany jest wyj¹tek braku autoryzacji. Przedstawia to listing \ref{list:req2}.

{\belowcaptionskip=-20pt
	\begin{lstlisting}[label=list:req2,caption=Logowanie]
	var user = await _context.AppUser.Include(x => x.Photos).FirstOrDefaultAsync(x => x.Email == request.Email, cancellationToken);
	
	if (user == null)
	throw new NotFoundException(nameof(Dto.User), request.Email);
	
	var result = await _signInManager.CheckPasswordSignInAsync(user, request.Password, false);
	
	if (result.Succeeded)
	{
		var roles = await _userManager.GetRolesAsync(user);
		
		return new Dto.User
		{
			Username = user.UserName,
			DisplayName = user.DisplayName,
			Token = _jwtGenerator.CreateToken(user),
			Image = user.Photos.FirstOrDefault(x => x.IsMain)?.Url,
			Role = roles.FirstOrDefault()
		};
	}
	throw new UnauthorizedException(request.Email);
	\end{lstlisting}
}

Logowanie jest konieczne, aby mieæ dostêp do reszty funkcjonalnoœci aplikacji. Podczas ka¿dego requesta do ka¿dego endpointa (za wyj¹tkiem logowania oraz rejestracji), sprawdzany jest token i w przypadku jego braku, lub niewa¿noœci zwracany jest kod 401, œwiadcz¹cy o braku autoryzacji. \\
\indent U¿ytkownik mo¿e posiadaæ jedn¹ z dwóch ról - Admin lub User. Podczas rejestracji domyœlnie ka¿demu nowemu u¿ytkownikowi przypisywana jest rola User. Zmiany mo¿na dokonaæ jedynie z poziomu bazy danych. Role te ró¿ni¹ siê dostêpem do poszczególnych funkcjonalnoœci aplikacji. 
U¿ytkownik nie ma dostêpu do metod zwi¹zanych z zarz¹dzaniem lig¹ oraz meczami, natomiast Admin ma dostêp do wszystkich funkcjonalnoœci systemu. Efekt ten osi¹gniêto dodaj¹c nag³ówki z autoryzacj¹ roli przy odpowiednich metodach w kontrollerach. Autoryzacjê metody rol¹ przedstawiono na przyk³adzie tworzenia meczu na listingu \ref{list:req3}.

{\belowcaptionskip=-20pt
	\begin{lstlisting}[label=list:req3,caption=Autoryzacja rol¹ metody tworzenia meczu]
	[HttpPost]
	[Authorize(Roles = "Admin")]
	public async Task<IActionResult> Create([FromBody] CreateMatchCommand command)
	{
		await Mediator.Send(command);		
		return NoContent();
	}
	\end{lstlisting}
}

\section{Profil u¿ytkownika}
Aplikacja posiada funkcjonalnoœæ wgrywania zdjêæ, które mo¿na nastêpnie wykorzystaæ jako avatar. Zdjêcie zostaje przypisane do u¿ytkownika, który je uploaduje, oraz zostaje wybrane jako zdjêcie g³ówne je¿eli jest to pierwsze zdjêcie wrzucone przez u¿ytkownika. Kod odpowiadaj¹cy za wgrywanie zdjêcia znajduje siê na listingu \ref{list:req4}.

{\belowcaptionskip=-20pt
	\begin{lstlisting}[label=list:req4,caption=Dodawanie nowego zdjêcia]
	var photoUploadResult = _photoAccessor.AddPhoto(request.File);
	
	var user = await _context.AppUser.Include(x => x.Photos)
	.SingleOrDefaultAsync(x => x.UserName == _userAccessor.GetCurrentUsername(), cancellationToken);
	
	var photo = new Photo
	{
		Url = photoUploadResult.Url,
		Id = photoUploadResult.PublicId
	};
	
	if (!user.Photos.Any(x => x.IsMain))
		photo.IsMain = true;
	
	user.Photos.Add(photo);
	
	var success = await _context.SaveChangesAsync(cancellationToken) > 0;
	if (success) return photo;
	throw new Exception("Problem saving changes");
	\end{lstlisting}
}

Zdjêcie wrzucone zostaje na serwis chmurowy cloudinary, a w bazie przechowywany jest link do wrzuconego zdjêcia.\\
\indent Zaimplementowano równie¿ mo¿liwoœæ podgl¹du profilu innych u¿ytkowników. Na podstawie przes³anej w requeœcie nazwy u¿ytkownika z bazy pobierane s¹ informacje na jego temat wraz ze zdjêciem g³ównym je¿eli takowe posiada. Do znalezienia u¿ytkownika wykorzystano metodê SingleOrDefaultAsync, co oznacza ¿e w przypadku braku u¿ytkownika o podanej nazwie funkcja rzuca wyj¹tek. Sposób pobierania danych na temat profilu przedstawia listing \ref{list:req5}.

{\belowcaptionskip=-20pt
	\begin{lstlisting}[label=list:req5,caption=Pobieranie danych na temat profilu]
	var user = await _context.AppUser.Include(x => x.Photos)
	.SingleOrDefaultAsync(x => x.UserName == request.Username, cancellationToken);
	
	return new Profile
	{
		DisplayName = user.DisplayName,
		Username = user.UserName,
		Image = user.Photos.FirstOrDefault(x => x.IsMain)?.Url,
		Photos = user.Photos,
		Bio = user.Bio
	};
	\end{lstlisting}
}


\section{Zarz¹dzanie lig¹}

Do prezentowanych poni¿ej funkcjonalnoœci dostêp ma jedynie u¿ytkownik z rol¹ Admin. \\
Aplikacja pozwala na dodawanie, edycje oraz usuwanie sezonów, dywizji, dru¿yn oraz zawodników. Do ka¿dego z wymienionych obiektów zaimplementowa³a zosta³a równie¿ walidacja wys³anych danych przy u¿yciu rozszerzenie Fluent Validation. Sposób implementacji tych podstawowych operacji CRUD przedstawiono na przyk³adzie obiektu sezonu. Je¿eli dane w zapytaniu przejd¹ walidacjê, której implementacjê przestawia listing \ref{list:req6} to nastêpuje przypisanie danych do obiektu \textit{Season}. Je¿eli w zapytaniu znajduj¹ siê dane na temat dywizji które maj¹ zostaæ przypisane do tego sezonu to równie¿ s¹ one dodawane, w przypadku ich braku operacja zostaje pominiêta i nastêpuje zapisanie sezonu do bazy. Je¿eli operacja przebieg³a prawid³owo zwracany jest Id sezonu, w innym przypadku rzucany jest wyj¹tek, co przedstawia listing \ref{list:req7}
{\belowcaptionskip=-20pt
	\begin{lstlisting}[label=list:req6,caption=Walidacja danych]
	RuleFor(x => x.Name)
	.NotEmpty();
	RuleFor(x => x.StartDate)
	.NotEmpty();
	\end{lstlisting}
}

{\belowcaptionskip=-20pt
	\begin{lstlisting}[label=list:req7,caption=Dodawanie nowego sezonu]
	var newSeasonDivisions = new List<SeasonDivision>();
	var season = new Season
	{
		Name = request.Name,
		StartDate = request.StartDate,
		EndDate = request.EndDate
	};
	
	if (request.DivisionsId.Any())
	{
		foreach (var divisionId in request.DivisionsId)
		{
			var seasonDivision = new SeasonDivision
			{
				Season = season,
				DivisionId = divisionId,
			};
			newSeasonDivisions.Add(seasonDivision);
		}
		_context.SeasonDivision.AddRange(newSeasonDivisions);
	}
	else
		_context.Season.Add(season);
	
	var success = await _context.SaveChangesAsync(cancellationToken) > 0;
	if (success) return season.Id;
	
	throw new Exception("Problem saving changes");
	\end{lstlisting}
}

Podczas edycji pobierany jest sezon za pomoc¹ Id, jeœli nie zostaje on znaleziony rzucany jest wyj¹tek. Po znalezieniu obiektu poszczególnym w³asnoœciom przypisywane s¹ nowe dane jeœli takowe zosta³y przys³ane, w przypadku ich braku zachowana zostaje stara wartoœæ. Sprawdzane s¹ równie¿ przys³ane dywizje które s¹ przypisane do sezonu, w przypadku nowych zostaj¹ one dodane. Usuwanie dywizji z sezonu znajduje siê w innej metodzie. Podczas wysy³ania danych do edycji równie¿ nastêpuje walidacja, analogiczna do tej podczas dodawania. Kod odpowiedzialny za edycjê znajduje siê na listingu \ref{list:req8}.

{\belowcaptionskip=-20pt
	\begin{lstlisting}[label=list:req8,caption=Edycja sezonu]
	var newSeasonDivisions = new List<SeasonDivision>();
	
	var entity = await _context.Season.FindAsync( request.Id);
	
	if (entity == null)
		throw new NotFoundException(nameof(Season), request.Id);
	
	entity.Name = request.Name ?? entity.Name;
	entity.StartDate = request.StartDate ?? entity.StartDate;
	entity.EndDate = request.EndDate ?? entity.EndDate;
	
	if (request.DivisionsId.Any())
	{
		var seasonDivisionsInDb = _context.SeasonDivision.Where(x => x.SeasonId == entity.Id).Select(x => x.DivisionId).ToList();
		foreach (var divisionId in request.DivisionsId)
		{
			var seasonDivision = new SeasonDivision
			{
				SeasonId = entity.Id,
				DivisionId = divisionId,
			};
			newSeasonDivisions.Add(seasonDivision);
		}
		newSeasonDivisions.RemoveAll(x => seasonDivisionsInDb.Contains(x.DivisionId));
		_context.SeasonDivision.AddRange(newSeasonDivisions);
	}
	
	var success = await _context.SaveChangesAsync(cancellationToken) > 0;
	if (success) return Unit.Value;
	
	throw new Exception("Problem saving changes");
	\end{lstlisting}
}

Usuwanie obiektu wykonywane jest na podstawie Id wys³anego w zapytaniu, dziêki po którym szuka siê sezonu do usuniêcia. Gdy takiego nie ma rzucany jest wyj¹tek. W przypadku powodzenia sezon zostaje usuniêty a zmiany zostaj¹ zapisane w bazie. W przypadku problemów z zapisem rzucany jest wyj¹tek. Omawian¹ sytuacjê przedstawia listing \ref{list:req9}.

{\belowcaptionskip=-20pt
	\begin{lstlisting}[label=list:req9,caption=Usuwanie sezonu]
	var entity = await _context.Season.FindAsync(request.Id, cancellationToken);
	
	if (entity == null)
		throw new NotFoundException(nameof(Season), request.Id);
	
	_context.Season.Remove(entity);
	
	var success = await _context.SaveChangesAsync(cancellationToken) > 0;
	if (success) return Unit.Value;
	
	throw new Exception("Problem saving changes");
	\end{lstlisting}
}

\indent Dru¿yny oraz zawodników przypisuje siê do sezonów oraz dywizji. Tworzy siê w ten sposób obiekty \textit{PlayerSeason} oraz \textit{TeamSeason}. Obiektowi zostaje przypisany Id sezonu oraz dywizji, którego ma dotyczyæ. Zapisany zostaje tak¿e Id dru¿yny do której w danym sezonie oraz dywizji zostaje zapisany. Warto zaznaczyæ ¿e jest to referencja do obiektu \textit{TeamSeason}, a nie \textit{Team}. Kod odpowiadaj¹cy za tworzenie obiektu \textit{PlayerSeason} przedstawia listing \ref{list:req10}, w przypadku \textit{TeamSeason} wygl¹da to analogicznie. 

{\belowcaptionskip=-20pt
	\begin{lstlisting}[label=list:req10,caption=Przypisywanie zawodnika do sezonu oraz dywizji]
	var seasonDivision = await _context.SeasonDivision.FirstOrDefaultAsync(
	x => x.SeasonId == request.SeasonId && x.DivisionId == request.DivisionId, cancellationToken);
	
	if (seasonDivision == null)
		throw new NotFoundException(nameof(SeasonDivision), request.SeasonId);
	
	var entity = new PlayerSeason
	{
		PlayerId = request.PlayerId,
		SeasonDivisionId = seasonDivision.Id,
		TeamId = request.TeamId,
		JerseyNr = request.JerseyNr,
	};
	
	_context.PlayerSeason.Add(entity);
	
	var success = await _context.SaveChangesAsync(cancellationToken) > 0;
	if (success) return Unit.Value;
	
	throw new Exception("Problem saving changes");
	\end{lstlisting}
}

W danym sezonie oraz dywizji ta sama dru¿yna mo¿e pojawiæ siê tylko raz. Tak samo w przypadku zawodników. Ograniczenie to zosta³o na³o¿one na poziomie bazy. Przedstawia je listing \ref{list:req11}.

{\belowcaptionskip=-20pt
	\begin{lstlisting}[label=list:req11,caption=Ograniczenie unikalnoœci TeamId oraz SeasonDivisionId]
	builder.HasIndex(e => new { e.TeamId, e.SeasonDivisionId })
	.HasName("UQ_Team_Season_Player_ID_Season_Division_ID")
	.IsUnique();
	\end{lstlisting}
}

Obiekty te mo¿na równie¿ edytowaæ oraz usuwaæ.

\section{Zarz¹dzanie meczami i program do pisania statystyk}
Mecze mo¿na planowaæ dodaj¹c je do bazy ustawiaj¹c w³aœciwoœæ StartDate na datê w przysz³oœci, mo¿na dodawaæ równie¿ mecze które odby³y siê w przesz³oœci. Podczas dodawania meczu w pierwszej kolejnoœci sprawdzane jest na podstawie daty rozpoczêcia meczu oraz dywizji przes³anej w zapytaniu czy dla wybranej daty zosta³ ju¿ utworzony sezon wraz z dywizj¹, je¿eli nie rzucany jest wyj¹tek. Nastêpnie pobierane s¹ dane na temat dru¿yn w sezonie, przy pomocy których tworzone s¹ obiekty \textit{TeamMatch} dla obu dru¿yn. Zostaj¹ one dodane do bazy oraz zapisane. Je¿eli operacja zakoñczy siê sukcesem tworzony jest obiekt meczu. Kod znajduje siê na listingu \ref{list:req12}.

{\belowcaptionskip=-20pt
	\begin{lstlisting}[label=list:req12,caption=Dodawanie nowego meczu]
	var seasonDivision = await_context.SeasonDivision
	.Include(x => x.Season).FirstOrDefaultAsync(x => x.DivisionId == request.DivisionId && x.Season.StartDate <= request.StartDate && x.Season.EndDate >= request.StartDate, cancellationToken);
	
	if (seasonDivision == null)
		throw new Exception("Matches cannot be scheduled for this season. Firstly create season.");
	
	var teamHome = await _context.TeamSeason.FirstOrDefaultAsync(x => x.Id == request.TeamHomeId, cancellationToken);
	var teamGuest = await _context.TeamSeason.FirstOrDefaultAsync(x => x.Id == request.TeamGuestId, cancellationToken);
	if (teamHome == null)
		throw new NotFoundException(nameof(TeamSeason),request.TeamHomeId);
	if (teamGuest == null)
		throw new NotFoundException(nameof(TeamSeason),request.TeamGuestId);
	
	var teamMatchHome = new TeamMatch { TeamId = teamHome.TeamId };
	var teamMatchGuest = new TeamMatch { TeamId = teamGuest.TeamId };
	
	_context.TeamMatch.AddRange(teamMatchHome, teamMatchGuest);
	
	var success = await _context.SaveChangesAsync(cancellationToken) > 0;
	if (!success) throw new Exception("Problem saving changes. Team match entity.");
	
	var entity = new Match
	{
		SeasonDivisionId = seasonDivision.Id,
		TeamSeasonHomeId = request.TeamHomeId,
		TeamSeasonGuestId = request.TeamGuestId,
		TeamHomeId = teamMatchHome.Id,
		TeamGuestId = teamMatchGuest.Id,
		Attendance = request.Attendance ?? 0,
		StartDate = request.StartDate,
		Ended = request.Ended ?? false
	};
	
	_context.Match.Add(entity);
	
	success = await _context.SaveChangesAsync(cancellationToken) > 0;
	if (success) return Unit.Value;
	
	throw new Exception("Problem saving changes");
	\end{lstlisting}
}

Po utworzeniu meczu nale¿y go rozpocz¹æ aby móc zbieraæ z niego statystyki. S³u¿y do tego metoda StartMatch, która znajduje siê na listingu \ref{list:req13}. W pierwszej kolejnoœci z bazy pobierany jest mecz który nale¿y rozpocz¹æ. W obiekcie zostaj¹ zapisane informacje na temat koloru koszulek obu zespo³ów. Tworzone s¹ równie¿ obiekty \textit{PlayerMatch} na podstawie przes³anych Id zawodników, którzy maj¹ zostaæ zg³oszeni do meczu.

{\belowcaptionskip=-20pt
	\begin{lstlisting}[label=list:req13,caption=Rozpoczynanie meczu]
	var match = await _context.Match.Include(x => x.PlayerMatches)
	.Include(x => x.Incidents).FirstOrDefaultAsync(x => x.Id == request.Id, cancellationToken);
	
	if (match == null)
		throw new NotFoundException(nameof(Match), request.Id);
	
	match.Started = true;
	match.TeamHomeJerseyColor = request.TeamHomeJerseyColor;
	match.TeamGuestJerseyColor = request.TeamGuestJerseyColor;
	
	var playerMatchList = new List<PlayerMatch>();
	
	foreach (var playerSeasonId in request.TeamHomePlayerSeasonIds)
	{
		var playerMatch = new PlayerMatch { PlayerSeasonId = playerSeasonId, MatchId = request.Id, IsGuest = false };
		playerMatchList.Add(playerMatch);
	}
	
	foreach (var playerSeasonId in request.TeamGuestPlayerSeasonIds)
	{
		var playerMatch = new PlayerMatch { PlayerSeasonId = playerSeasonId, MatchId = request.Id, IsGuest = true };
		playerMatchList.Add(playerMatch);
	}
	
	_context.PlayerMatch.AddRange(playerMatchList);
	
	var success = await _context.SaveChangesAsync(cancellationToken) > 0;
	if (success) return Unit.Value;
	
	throw new Exception("Problem saving changes");
	\end{lstlisting}
}

Pisanie statystyk polega na wysy³aniu poszczególnych wydarzeñ. Aplikacja obs³uguje nastêpuj¹ce zdarzenia: rzuty, zbiórki, straty, przechwyty, faule, rzuty wolne i przerwy na ¿¹danie. Ka¿dy z obiektów opisuj¹cych zdarzenie ma relacjê z tabel¹ \textit{Incident}, która zawiera w sobie informacje na temat czasu i typu wydarzenia, oraz meczu i kwarty w którym mia³o miejsce. Dodawanie nowych zdarzeñ przedstawiono na przyk³adzie dodania nowego rzutu na listingu \ref{list:req14}. W pierwszej kolejnoœci sprawdzane jest czy dla zawodnika który jest przypisany jako oddaj¹cy rzut zosta³ stworzony obiekt \textit{PlayerMatch}, je¿eli nie, to jest on tworzony. Nastêpnie w zale¿noœci od tego czy rzut by³ o wartoœci dwóch lub trzech punktów oraz czy by³ celny odpowiednio aktualizuje siê pola w obiekcie \textit{TeamMatch} oraz \textit{PlayerMatch}. Je¿eli w ¿¹daniu zosta³ przekazany Id zawodnika, który asystowa³, b¹dŸ Id zbieraj¹cego to dodawane s¹ równie¿ asysta i zbiórka.

{\belowcaptionskip=-20pt
	\begin{lstlisting}[label=list:req14,caption=Dodawanie rzutu]
	var playerMatch = await GetPlayerMatchAndAddIfNotExistYet(request, cancellationToken);
	
	if (Shot.Value == 2)
	{
		TeamMatch.Fg2a++;
		playerMatch.Fg2a++;
		if (Shot.IsAccurate)
		{
			TeamMatch.Fg2m++;
			playerMatch.Fg2m++;
		}
	}
	else if (Shot.Value == 3)
	{
		TeamMatch.Fg3a++;
		playerMatch.Fg3a++;
		if (Shot.IsAccurate)
		{
			TeamMatch.Fg3m++;
			playerMatch.Fg3m++;
		}
	}
	
	if (request.PlayerAssistId.HasValue)
		await AddAssist(request, cancellationToken);
	
	if (request.PlayerReboundId.HasValue||request.TeamReboundId.HasValue)
		await AddRebound(request, cancellationToken);
	
	_context.Shot.Add(Shot);
	var success = await _context.SaveChangesAsync(cancellationToken) > 0;
	if (success) return incident;
	
	throw new Exception("Error saving changes");
	\end{lstlisting}
}


\section{Przesy³anie wyniku meczu na ¿ywo}
Funkcjonalnoœæ przesy³ania wyniku meczu na ¿ywo zosta³a zaimplementowana przy u¿yciu biblioteki SignalR.
Przy jej pomocy stworzono Hub o nazwie IncidentsHub, którego implementacja znajduje siê na listingu \ref{list:req15}. Podczas dodawania nowego rzutu mediator wysy³a komendê utworzenia rzutu, co wywo³uje metodê omówion¹ w poprzedniej sekcji przedstawion¹ na listingu \ref{list:req14}. Po dodaniu tej rzutu do bazy, do wszystkich klientów huba zostaje wys³any event informuj¹cy o tym, ¿e rzut zosta³ otrzymany - ,,ReceiveShot'', wraz z informacjami na jego temat.

{\belowcaptionskip=-20pt
	\begin{lstlisting}[label=list:req15,caption=Definicja klasy IncidentsHub]
	public class IncidenctsHub : Hub
	{
		public IMediator _mediator { get; }
		
		public IncidenctsHub(IMediator mediator)
		{
			_mediator = mediator;
		}
		
		public async Task SendShot(CreateShotCommand command)
		{
			var incident = await _mediator.Send(command);
			
			await Clients.All.SendAsync("ReceiveShot", incident.Shot.IsAccurate, incident.IsGuest, incident.Shot.Value, incident.MatchId, incident.Quater, incident.Minutes, incident.Seconds, incident.Id);
		}
	}
	\end{lstlisting}
}

Aby dodaæ nowy rzut nale¿y go wys³aæ do endpointa ,,/incidentsHub'' który wczeœniej zosta³ skonfigurowany w klasie Startup, jak pokazuje listing \ref{list:req16}.

{\belowcaptionskip=-20pt
	\begin{lstlisting}[label=list:req16,caption=Konfiguracja endpointa pozwalaj¹cego na œledzenie wyniku na ¿ywo]
		app.UseEndpoints(endpoints =>
		{
			endpoints.MapHub<IncidenctsHub>("/incidentsHub");
			endpoints.MapControllers();
		});
	\end{lstlisting}
}

Aplikacja kliencka ³¹czy siê do huba przez wczeœniej skonfigurowanego endpointa, przesy³aj¹c przy tym token. Dopóki po³¹czenie jest aktywne hub jest obserwowany czy nie wyst¹pi³ event ,,ReceiveShot'', w przypadku jego wyst¹pienia aktualizowany jest wynik meczu. Po zamkniêciu strony b¹dŸ aplikacji po³¹czenie z hubem jest przerywane. Kod znajduje siê na listingu \ref{list:req17}.

{\belowcaptionskip=-20pt
	\begin{lstlisting}[label=list:req17,caption=Pod³¹czenie do huba od strony klienta]
	@action createHubConnection = () => {
		this.hubConnection = new HubConnectionBuilder()
		.withUrl("http://localhost:5000/incidentsHub", {
			accessTokenFactory: () => this.rootStore.commonStore.token!,
		})
		.configureLogging(LogLevel.Information)
		.build();
		
		this.hubConnection.start()
		.then(() => console.log(this.hubConnection!.state))
		.catch((err) => {
			console.log(err);
		});
		
		this.hubConnection.on(
		"ReceiveShot",
		(isAccurate, isGuest, value, matchId, quater, minutes, seconds) => {
			runInAction(() =>
			this.updateScoreLogic(matchId, quater, minutes, seconds, isAccurate, isGuest, value));
		});
	};
	
	@action stopHubConnection = () => {
		this.hubConnection?.stop();
	};
	\end{lstlisting}
}

