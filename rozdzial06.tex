\chapter{Implementacja}

\section{Rejestracja, logowanie oraz role}
Do stworzenia u¿ytkowników wykorzystano wbudowany w .NETa interfejs API o nazwie Identity, który pozwala na zarz¹dzanie u¿ytkownikami, has³ami, danymi profilu, rolami oraz tokenami.
Po rejestracji informacje na temat u¿ytkownika zachowywane s¹ w bazie, jego has³o zostaje zhaszowane (tym zajmuje siê Identity, przez co nie by³o potrzeby implementacji tego na w³asn¹ rêkê).
Przed samym procesem tworzenia u¿ytkownika nastêpuje sprawdzenie, czy u¿ytkownik o podanych danych nie znajduje siê ju¿ w bazie i w takim przypadku proces przerywany zostaje wyj¹tkiem.\\
Je¿eli jest to nowy u¿ytkownik, na podstawie przes³anych danych tworzony jest obiekt \textit{AppUsera} oraz przypisana zostaje mu rola.
W przypadku gdy u¿ytkownik zostanie pomyœlnie dodany do bazy zwracany jest obiekt \textit{User} wraz z wygenerowanym tokenem pozwalaj¹cym na automatyczne zalogowanie siê do aplikacji. Kod odpowiadaj¹cy za rejestracjê nowego u¿ytkownika znajduje siê na listingu \ref{list:req1}.
\lstset{style=sharpcstyle}
{\belowcaptionskip=-20pt
\begin{lstlisting}[label=list:req1,caption=Rejestracja nowego u¿ytkownika]
	if (await _context.AppUser.AnyAsync(x => x.Email == request.Email, cancellationToken))
	throw new BadRequestException("Email already exist");
	
	if (await _context.AppUser.AnyAsync(x => x.UserName == request.UserName, cancellationToken))
	throw new BadRequestException("Username already exist");
	
	var user = new AppUser
	{
		DisplayName = request.DisplayName,
		Email = request.Email,
		UserName = request.UserName,
	};
	
	var result = await _userManager.CreateAsync(user, request.Password);
	await _userManager.AddToRoleAsync(user, "USER");
	
	if (result.Succeeded)
	{
		return new Dto.User
		{
			DisplayName = user.DisplayName,
			Username = user.UserName,
			Token = _jwtGenerator.CreateToken(user),
		};
	}
	throw new Exception("Problem creating user");
\end{lstlisting}
}

Podczas logowania nastêpuje sprawdzenie czy u¿ytkownik istnieje w bazie i czy has³o jest prawid³owe. Je¿eli tak z bazy zostaje pobierana rola przypisana do u¿ytkownika oraz adres url zdjêcia je¿eli takowe wczeœniej zosta³o wrzucone i generowany jest token. W przypadku niepowodzenia zwracany jest wyj¹tek braku autoryzacji. Przedstawia to listing \ref{list:req2}.

{\belowcaptionskip=-20pt
	\begin{lstlisting}[label=list:req2,caption=Logowanie]
	var user = await _context.AppUser.Include(x => x.Photos).FirstOrDefaultAsync(x => x.Email == request.Email, cancellationToken);
	
	if (user == null)
	throw new NotFoundException(nameof(Dto.User), request.Email);
	
	var result = await _signInManager.CheckPasswordSignInAsync(user, request.Password, false);
	
	if (result.Succeeded)
	{
		var roles = await _userManager.GetRolesAsync(user);
		
		return new Dto.User
		{
			Username = user.UserName,
			DisplayName = user.DisplayName,
			Token = _jwtGenerator.CreateToken(user),
			Image = user.Photos.FirstOrDefault(x => x.IsMain)?.Url,
			Role = roles.FirstOrDefault()
		};
	}
	throw new UnauthorizedException(request.Email);
	\end{lstlisting}
}

Logowanie jest konieczne, aby mieæ dostêp do reszty funkcjonalnoœci aplikacji. Podczas ka¿dego requesta do ka¿dego endpointa (za wyj¹tkiem logowania oraz rejestracji), sprawdzany jest token i w przypadku jego braku, lub niewa¿noœci zwracany jest kod 401, œwiadcz¹cy o braku autoryzacji. \\
\indent U¿ytkownik mo¿e posiadaæ jedn¹ z dwóch ról - Admin lub User. Podczas rejestracji domyœlnie ka¿demu nowemu u¿ytkownikowi przypisywana jest rola User. Zmiany mo¿na dokonaæ jedynie z poziomu bazy danych. Role te ró¿ni¹ siê dostêpem do poszczególnych funkcjonalnoœci aplikacji. 
U¿ytkownik nie ma dostêpu do metod zwi¹zanych z zarz¹dzaniem lig¹ oraz meczami, natomiast Admin ma dostêp do wszystkich funkcjonalnoœci systemu. Efekt ten osi¹gniêto dodaj¹c nag³ówki z autoryzacj¹ roli przy odpowiednich metodach w kontrollerach. Autoryzacjê metody rol¹ przedstawiono na przyk³adzie tworzenia meczu na listingu \ref{list:req3}.

{\belowcaptionskip=-20pt
	\begin{lstlisting}[label=list:req3,caption=Autoryzacja rol¹ metody tworzenia meczu]
	[HttpPost]
	[Authorize(Roles = "Admin")]
	public async Task<IActionResult> Create([FromBody] CreateMatchCommand command)
	{
		await Mediator.Send(command);		
		return NoContent();
	}
	\end{lstlisting}
}

\section{Profil u¿ytkownika}
Aplikacja posiada funkcjonalnoœæ wgrywania zdjêæ, które mo¿na nastêpnie wykorzystaæ jako avatar. Zdjêcie zostaje przypisane do u¿ytkownika, który je uploaduje, oraz zostaje wybrane jako zdjêcie g³ówne je¿eli jest to pierwsze zdjêcie wrzucone przez u¿ytkownika. Kod odpowiadaj¹cy za wgrywanie zdjêcia znajduje siê na listingu \ref{list:req4}.

{\belowcaptionskip=-20pt
	\begin{lstlisting}[label=list:req4,caption=Dodawanie nowego zdjêcia]
	var photoUploadResult = _photoAccessor.AddPhoto(request.File);
	
	var user = await _context.AppUser.Include(x => x.Photos)
	.SingleOrDefaultAsync(x => x.UserName == _userAccessor.GetCurrentUsername(), cancellationToken);
	
	var photo = new Photo
	{
		Url = photoUploadResult.Url,
		Id = photoUploadResult.PublicId
	};
	
	if (!user.Photos.Any(x => x.IsMain))
		photo.IsMain = true;
	
	user.Photos.Add(photo);
	
	var success = await _context.SaveChangesAsync(cancellationToken) > 0;
	if (success) return photo;
	throw new Exception("Problem saving changes");
	\end{lstlisting}
}

Zdjêcie wrzucone zostaje na serwis chmurowy cloudinary, a w bazie przechowywany jest link do wrzuconego zdjêcia.\\
\indent Zaimplementowano równie¿ mo¿liwoœæ podgl¹du profilu innych u¿ytkowników. Na podstawie przes³anej w requeœcie nazwy u¿ytkownika z bazy pobierane s¹ informacje na jego temat wraz ze zdjêciem g³ównym je¿eli takowe posiada. Do znalezienia u¿ytkownika wykorzystano metodê SingleOrDefaultAsync, co oznacza ¿e w przypadku braku u¿ytkownika o podanej nazwie funkcja rzuca wyj¹tek. Sposób pobierania danych na temat profilu przedstawia listing \ref{list:req5}.

{\belowcaptionskip=-20pt
	\begin{lstlisting}[label=list:req5,caption=Pobieranie danych na temat profilu]
	var user = await _context.AppUser.Include(x => x.Photos)
	.SingleOrDefaultAsync(x => x.UserName == request.Username, cancellationToken);
	
	return new Profile
	{
		DisplayName = user.DisplayName,
		Username = user.UserName,
		Image = user.Photos.FirstOrDefault(x => x.IsMain)?.Url,
		Photos = user.Photos,
		Bio = user.Bio
	};
	\end{lstlisting}
}


\section{Zarz¹dzanie lig¹}

Jest to implementacja funkcjonalnoœci do których dostêp ma jedynie u¿ytkownik z rol¹ Admin. \\
Aplikacja pozwala na dodawanie, edycje oraz usuwanie sezonów, dywizji, dru¿yn oraz zawodników. Do ka¿dego z wymienionych obiektów zaimplementowa³a zosta³a równie¿ walidacja wys³anych danych przy u¿yciu rozszerzenie Fluent Validation. Sposób implementacji tych podstawowych operacji CRUD przedstawiono na przyk³adzie obiektu sezonu. Je¿eli dane w zapytaniu przejd¹ walidacjê, której implementacjê przestawia listing \ref{list:req6} to nastêpuje przypisanie danych do obiektu \textit{Season}. Je¿eli w zapytaniu znajduj¹ siê dane na temat dywizji które maj¹ zostaæ przypisane do tego sezonu to równie¿ s¹ one dodawane, w przypadku ich braku operacja zostaje pominiêta i nastêpuje zapisanie sezonu do bazy. Je¿eli operacja przebieg³a prawid³owo zwracany jest Id sezonu, w innym przypadku rzucany jest wyj¹tek, co przedstawia listing \ref{list:req7}
{\belowcaptionskip=-20pt
	\begin{lstlisting}[label=list:req6,caption=Walidacja danych]
	RuleFor(x => x.Name)
	.NotEmpty();
	RuleFor(x => x.StartDate)
	.NotEmpty();
	\end{lstlisting}
}

{\belowcaptionskip=-20pt
	\begin{lstlisting}[label=list:req7,caption=Dodawanie nowego sezonu]
	var newSeasonDivisions = new List<SeasonDivision>();
	var season = new Season
	{
		Name = request.Name,
		StartDate = request.StartDate,
		EndDate = request.EndDate
	};
	
	if (request.DivisionsId.Any())
	{
		foreach (var divisionId in request.DivisionsId)
		{
			var seasonDivision = new SeasonDivision
			{
				Season = season,
				DivisionId = divisionId,
			};
			newSeasonDivisions.Add(seasonDivision);
		}
		_context.SeasonDivision.AddRange(newSeasonDivisions);
	}
	else
	{
		_context.Season.Add(season);
	}
	
	var success = await _context.SaveChangesAsync(cancellationToken) > 0;
	if (success) return season.Id;
	
	throw new Exception("Problem saving changes");
	\end{lstlisting}
}

Podczas edycji pobierany jest sezon za pomoc¹ Id, jeœli nie zostaje on znaleziony rzucany jest wyj¹tek. Po znalezieniu obiektu poszczególnym w³asnoœciom przypisywane s¹ nowe dane jeœli takowe zosta³y przys³ane, w przypadku ich braku zachowana zostaje stara wartoœæ. Sprawdzane s¹ równie¿ przys³ane dywizje które s¹ przypisane do sezonu, w przypadku nowych zostaj¹ one dodanych. Usuwanie dywizji z sezonu znajduje siê w innej metodzie. Podczas wysy³ania danych do edycji równie¿ nastêpuje walidacja, analogiczna do tej podczas dodawania. Kod odpowiedzialny za edycjê znajduje siê na listingu \ref{list:req8}.

{\belowcaptionskip=-20pt
	\begin{lstlisting}[label=list:req8,caption=Edycja sezonu]
	var newSeasonDivisions = new List<SeasonDivision>();
	
	var entity = await _context.Season.FindAsync( request.Id);
	
	if (entity == null)
		throw new NotFoundException(nameof(Season), request.Id);
	
	entity.Name = request.Name ?? entity.Name;
	entity.StartDate = request.StartDate ?? entity.StartDate;
	entity.EndDate = request.EndDate ?? entity.EndDate;
	
	if (request.DivisionsId.Any())
	{
		var seasonDivisionsInDb = _context.SeasonDivision.Where(x => x.SeasonId == entity.Id).Select(x => x.DivisionId).ToList();
		foreach (var divisionId in request.DivisionsId)
		{
			var seasonDivision = new SeasonDivision
			{
				SeasonId = entity.Id,
				DivisionId = divisionId,
			};
			newSeasonDivisions.Add(seasonDivision);
		}
		newSeasonDivisions.RemoveAll(x => seasonDivisionsInDb.Contains(x.DivisionId));
		_context.SeasonDivision.AddRange(newSeasonDivisions);
	}
	
	var success = await _context.SaveChangesAsync(cancellationToken) > 0;
	if (success) return Unit.Value;
	
	throw new Exception("Problem saving changes");
	\end{lstlisting}
}

Usuwanie obiektu wykonywane jest na podstawie Id wys³anego w zapytaniu, dziêki po którym szuka siê sezonu do usuniêcia. Gdy takiego nie ma rzucany jest wyj¹tek. W przypadku powodzenia sezon zostaje usuniêty a zmiany zostaj¹ zapisane w bazie. W przypadku problemów z zapisem rzucany jest wyj¹tek. Omawian¹ sytuacjê przedstawia listing \ref{list:req9}.

{\belowcaptionskip=-20pt
	\begin{lstlisting}[label=list:req9,caption=Usuwanie sezonu]
	var entity = await _context.Season.FindAsync(request.Id, cancellationToken);
	
	if (entity == null)
		throw new NotFoundException(nameof(Season), request.Id);
	
	_context.Season.Remove(entity);
	
	var success = await _context.SaveChangesAsync(cancellationToken) > 0;
	if (success) return Unit.Value;
	
	throw new Exception("Problem saving changes");
	\end{lstlisting}
}

\subsection{Zarz¹dzanie dru¿ynami oraz zawodnikami}
Dru¿yny oraz zawodników przypisuje siê do sezonów oraz dywizji. Tworzy siê w ten sposób obiekty \textit{PlayerSeason} oraz \textit{TeamSeason}. Obiektowi zostaje przypisany Id sezonu oraz dywizji, którego ma dotyczyæ. Zapisany zostaje tak¿e Id dru¿yny do której w danym sezonie oraz dywizji zostaje zapisany. Warto zaznaczyæ ¿e jest to referencja do obiektu \textit{TeamSeason}, a nie \textit{Team}. Kod odpowiadaj¹cy za tworzenie obiektu przedstawia poni¿szy listing \ref{list:req10}. 

{\belowcaptionskip=-20pt
	\begin{lstlisting}[label=list:req10,caption=Przypisywanie zawodnika do sezonu oraz dywizji]
	var seasonDivision = await _context.SeasonDivision.FirstOrDefaultAsync(
	x => x.SeasonId == request.SeasonId && x.DivisionId == request.DivisionId, cancellationToken);
	
	if (seasonDivision == null)
		throw new NotFoundException(nameof(SeasonDivision), request.SeasonId);
	
	var entity = new PlayerSeason
	{
		PlayerId = request.PlayerId,
		SeasonDivisionId = seasonDivision.Id,
		TeamId = request.TeamId,
		JerseyNr = request.JerseyNr,
	};
	
	_context.PlayerSeason.Add(entity);
	
	var success = await _context.SaveChangesAsync(cancellationToken) > 0;
	if (success) return Unit.Value;
	
	throw new Exception("Problem saving changes");
	\end{lstlisting}
}


\section{Zarz¹dzanie meczami i program do pisania statystyk}

\section{Przesy³anie wyniku meczu na ¿ywo}
%\section{Logowanie i rejestracja}
%¯e na pocz¹tku widoczny jest ekran logowania lub rejestracji. Jest to konieczne w celu autoryzacji czy u¿ytkownik jest adminem i ma dostep do czêœci odpowiedzialnych za zarz¹dzanie lig¹, czy ma dostêp jedynie do przegl¹dania danych na niej zawartych.
%\section{Panel zarz¹dzania lig¹}
%Ogólnie o zak³adce manage. Dostêp ma do niej tylko admin. Z jej poziomu mo¿emy dodawaæ do bazy nowych zawodników oraz dru¿yny wraz z logiem które dziêki paczce mo¿emy fajnie.
%Zarz¹dzanie sezonem tj. tworzenie nowych sezonów, przypisywanie do nich dywizji. Zarz¹dzenie dru¿ynami przypisanymi do danej w dywizji w danym sezonie.
%A nastepnie przypisywanie zawodnikow do druzyn w danym sezonie.
%Zakladka division w ktorej wlasciwie tylko mamy mozliwosc dodawania badz usuwanie dywizji.
%\section{Zak³adka match manager}
%Mo¿emy tu planowaæ przysz³e mecze, oraz ewentualnie dopisywaæ mecze które siê ju¿ odby³y.
%Po stworzeniu meczu mo¿na pisaæ z niego statystyki. I ogólnie o programie do  
%statystyk.
%
%\section{Zak³adka schedule}
%W tej zak³adce dostêpne s¹ do podejrzenia wszystkie mecze które s¹ zaplanowane, trwaj¹ b¹dŸ ju¿ siê odby³y posortowane po dacie. Mo¿na wejœæ w informacje na temat meczu klikaj¹c na box score. Dostaniemy wtedy informacje na temat statystyk ka¿dego zawodnika z meczu, oraz wchodz¹c w zak³adkê play by play ka¿d¹ akcjê z meczu.
%Warto zaznaczyæ ¿e dzia³a tu funkcja wyniku live.
%
%\section{Zak³adka stats}
%
%Statystyki zawodników oraz dru¿yn, z mo¿liwoœci¹ filtrowania po sezonie i dywizji. Domyœlnie wybierany jest aktualny seazon z najwy¿sza dywizj¹.
%
%\section{Zak³adka players}
%Wypisani wszyscy zawodnicy z ligi, mo¿liwoœæ filtrowania ich po pierwszej literze nazwiska. Po wejœciu w zawodnika s¹ informacje o nim. Statystyki ze wszystkich sezonów oraz dywizji. W teams analogicznie + logo.
%
%\section{Profil u¿ytkownika}
%Opcja dodawania zdjêæ i ustawianie jednego z nich jako zdjêcie g³ówne.
%
%
%\section{Zak³adka tabele}
%Tabele pokazuj¹ce dru¿yny i ich punkty, opcja filtrowania anal do stats.
